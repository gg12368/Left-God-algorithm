分析：

1>插⼊排序是原地排序算法吗？
从实现过程可以很明显地看出，插⼊排序算法的运⾏并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是⼀个原地排序算法。

2>插⼊排序是稳定的排序算法吗？
在插⼊排序中，对于值相同的元素，我们可以选择将后⾯出现的元素，插⼊到前⾯出现元素的后⾯，这样就可以保持原有的前后顺序不变，所以插⼊排序是稳定的排序算法。

3>插⼊排序的时间复杂度是多少？
如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组⾥⾯查找插⼊位置，
每次只需要⽐较⼀个数据就能确定插⼊的位置。
所以这种情况下，最好是时间复杂度为O(n)。注意，这⾥是从尾到头遍历已经有序的数据.
如果数组是倒序的，每次插⼊都相当于在数组的第⼀个位置插⼊新的数据，**所以需要移动⼤量的数据，所以最坏情况时间复杂度为 O(n^2)。

还记得我们在数组中插⼊⼀个数据的平均时间复杂度是多少吗？
O(n)。所以，对于插⼊排序来说，每次插⼊操作都相当于在数组中插⼊⼀个数据，循环执⾏ n 次插⼊操作，所以平均时间复杂度为 O(n^2)。




直接插⼊排序or冒泡排序
冒泡排序和插⼊排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插⼊排序要⽐冒泡排序更受欢迎呢？
我们前⾯分析冒泡排序和插⼊排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是⼀个固定值。插⼊排序是同样的，不管怎么优化，元素移动的次数也是固定的。但是，从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，⽽插⼊排序只需要 1 个。我们来看这段操作：

//冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
	int tmp = a[j];
	a[j] = a[j+1];
	a[j+1] = tmp;
	flag = true;
}
//插⼊排序中数据的移动操作：
if (a[j] > value) {
	a[j+1] = a[j]; // 数据移动
	} else {
	break; 
}

我们把执⾏⼀个赋值语句的时间粗略地计为单位时间（unit_time），然后分别⽤冒泡排序和插⼊排序对同⼀个逆序度是 K 的数组进⾏排序。
⽤冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。⽽插⼊排序中数据移动操作只需要 K 个单位时间。
所以，虽然冒泡排序和插⼊排序在时间复杂度上是⼀样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定⾸选插⼊排序。
插⼊排序的算法思路也有很⼤的优化空间，我们只是讲了最基础的⼀种。希尔排序就是对插⼊排序做了改进得来的排序算法。

