1.桶排序的性能分析

（1）时间复杂度分析：
我们把n个数据均匀地划分到m个桶内，每个桶里就有k=n/m个元素。每个桶内部再使用快速排序，时间复杂度为O(k * logk)。
m个桶排序的时间复杂度就是O(m * k * logk)，因为k = n / m，所以整个桶排序的时间复杂度为O(n * log(n / m))。
当桶的个数m接近数据个数n的时候，log(n / m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。

（2）空间复杂度分析：
在分析时间复杂度的时候可以发现，桶排序的时间复杂度取决于对各个桶之间数据进行排序的时间复杂度，
很明显，桶划分的越小，各个桶之间的数据越少，排序所有的时间也会很少，但是相应的空间消耗就会比较大，典型的空间换时间的做法。
桶排序要有两个数组的空间开销，一个存放待排序数组，还需要一个额外的，
就是所谓的桶，比如待排序的值是0到m-1，那就需要m个桶，这个桶数组至少需要m个空间，所以桶排序的空间复杂度为：O(n)

（3）稳定性分析：
排序过程中，元素两两交换时，相同元素的前后顺序没有发生改变，所以归并排序是一种稳定排序算法。




2.桶排序的适用场景
可以看到我们上面在对时间复杂度分析的时候，做了很多的假设，最后才得出时间复杂度为O(n)，可以看出来桶排序对要排序的数据的要求还是十分苛刻的。

首先，要排序的n个数据要很容易的划分到m个桶里，并且桶与桶之间有着天然的大小顺序。
这样每个桶内的数据都排序完成后，桶与桶之间的数据不需要再进行排序。

其次，数据在各个桶之间的分布是比较均匀的。
如果数据经过桶划分之后，有些桶里面的数据非常多，有些非常少，很不平均，那桶内数据的时间复杂度就不再是常量级了。
在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)的排序算法了。

从上面的分析可以看出来，桶排序比较适合在外部排序中，所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

比如说我们有10GB的订单数据，我们希望按订单金额进行排序，
但是我们的内存有限，只有几百MB，没有办法一次性将10GB的数据全都加载到内存中，这个时候我们就可以借助桶排序来解决这个问题了。
我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到订单金额最小是1元，最大是10万元。
我们将所有订单根据金额划分到100个桶里，第一个桶我们存储金额在1元到1000元之间的订单，第二个桶存储金额在1001元到2000元之内的订单，以此类推。
每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02 .... 99）。

理想的情况下，如果订单金额在1到10万之间均匀分布，那订单会被均匀划分到100个文件中，
每个小文件中大约存储100MB的订单数据，我们就可以将这100个小文件依次放到内存中，再用快速排序来排序，
等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个文件中的订单数据，并将其写入一个文件中，
那这个文件中存储的就是按照金额从小到大的订单数据了。

不过你可能也发现，订单按照金额在1元到10万元之间并不一定是均匀的，所以10GB订单数据是无法均匀地划分到100个文件中的。
有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。
那么针对这些划分之后还是比较大的文件，我们可以继续划分，
比如：订单金额在1到1000元的数据比较多，我们就将这个区间继续划分为10个小区间，1~100，101~200 ... 901~1000元。
如果划分之后，101~200元之间的订单还是太多，无法一次读入内存，那就再继续进行划分，直到所有的文件都能读入到内存为止。
